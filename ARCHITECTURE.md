# Архітектура проєкту Conpanio

Цей документ надає детальний огляд архітектурних рішень, прийнятих під час розробки асистента Conpanio.

## 1. Загальна архітектура (Model-View-Controller)

Проєкт має чітко розділену архітектуру, що нагадує патерн **Model-View-Controller (MVC)**, де кожен компонент виконує свою, чітко визначену роль. Це робить код більш організованим, легшим для тестування та подальших модифікацій.

- **`main.py`**: Точка входу в програму. Ініціалізує `colorama`, завантажує дані з файлу за допомогою `data.py` і запускає головний цикл навігації `nav.py`. При коректному виході з програми зберігає дані.

- **`nav.py`**: Відповідає за головний цикл програми (REPL - Read-Eval-Print Loop). Він отримує ввід від користувача, розбирає його на команду та аргументи, і на основі команди викликає відповідний обробник (хендлер) з пакета `handlers/`.

- **`data.py`**: Шар персистентності (збереження даних). Відповідає за збереження стану `AddressBook` у файл (`.pkl`) та завантаження з нього. Ізолює решту програми від деталей роботи з файловою системою.

- **`book/` (Model)**: Пакет моделей даних. Містить класи, що описують сутності: `AddressBook`, `Record`, та поля (`Name`, `Phone`, `Note` тощо). Цей шар нічого не знає про інтерфейс користувача чи логіку команд; він лише визначає структуру даних та їхню поведінку.

- **`handlers/` (Controller)**: Пакет обробників команд. Це "мозок" програми. Кожен файл `handle_*.py` реалізує логіку для конкретної команди. Хендлери:

  - Отримують дані від `nav.py`.
  - Взаємодіють з моделями з `book/` (читають, створюють, оновлюють, видаляють дані).
  - Використовують `ui.py` для будь-якої взаємодії з користувачем (виведення помилок, запит додаткової інформації).
  - Для форматування даних у складні представлення (наприклад, таблиці) викликають `formatter.py`.

- **`formatter.py` та `ui.py` (View)**: Компоненти представлення.
  - **`formatter.py`**: Знає, як перетворити одну або кілька моделей даних (`Record`) у відформатований для читання рядок, наприклад, у вигляді таблиці. Він не виводить нічого в консоль, лише повертає готовий рядок.
  - **`ui.py`**: Шар інтерфейсу користувача. Надає прості функції для взаємодії з консоллю: виведення тексту певним кольором (`print_line`, `print_error`), виведення меню, отримання вводу від користувача (`prompt_user`).

Такий поділ дозволяє легко змінювати частини системи незалежно одна від одної. Наприклад, можна замінити консольний інтерфейс (`ui.py`) на графічний або веб-інтерфейс, не змінюючи при цьому бізнес-логіку в `handlers/` чи моделі в `book/`.

---

## 2. Ключове архітектурне рішення: Рефакторинг обробників

Одним із ключових архітектурних покращень у проєкті, що стало своєрідним викликом, було перенесення логіки обробки команд у спеціалізований пакет `handlers/`. Це класичний приклад застосування принципу **"Висока згуртованість, низька зв'язаність" (High Cohesion, Low Coupling)**.

- **Висока згуртованість:** Усі компоненти, що відповідають за одну задачу (обробку команд), зібрані разом у пакеті `handlers`.
- **Низька зв'язаність:** Модуль навігації (`nav.py`) тепер не залежить від конкретних реалізацій команд, а лише від єдиного інтерфейсу — словника `COMMAND_HANDLERS`.

### Переваги цього рішення

1.  **Чітке розділення відповідальності (Separation of Concerns)**

    - **`nav.py` (Диспетчер):** Його єдина роль — отримати команду від користувача, знайти відповідний обробник у словнику та викликати його. Він не знає, _як_ команди виконуються.
    - **`handlers/` (Виконавець):** Цей пакет інкапсулює всю логіку. Він знає, які команди існують, як вони реалізовані, і надає єдину точку доступу до них.

2.  **Простота розширення та підтримки**

    - **Легко додати нову команду:** Щоб створити нову функціональність (наприклад, `search-email`), достатньо додати файл `handle_search_email.py` та прописати його у `handlers/__init__.py`. **Файл `nav.py` при цьому не змінюється.**
    - **Чистота коду:** Замість десятка імпортів у `nav.py` тепер лише один: `from handlers import COMMAND_HANDLERS`.

3.  **Надійний та інкапсульований API**
    - Пакет `handlers` надає чіткий "публічний API" — словник `COMMAND_HANDLERS`.
    - Окремі функції, як-от `handle_add` чи `handle_delete`, є внутрішніми деталями реалізації. Вони не експортуються через `__all__`, що запобігає їх випадковому використанню ззовні та робить інтерфейс пакета чистим і передбачуваним.

### Результат

Ми отримали значно гнучкішу та надійнішу систему. `nav.py` став стабільним компонентом, а вся логіка команд розвивається незалежно у власному, добре організованому пакеті `handlers`. Це рішення є фундаментом для подальшого масштабування проєкту.
